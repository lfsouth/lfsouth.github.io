<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Teches on lfsouth</title><link>https://lfsouth.com/tech/</link><description>Recent content in Teches on lfsouth</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 26 Jul 2022 21:27:10 +0200</lastBuildDate><atom:link href="https://lfsouth.com/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>我对于terminal的认知</title><link>https://lfsouth.com/tech/terminal/</link><pubDate>Tue, 26 Jul 2022 21:27:10 +0200</pubDate><guid>https://lfsouth.com/tech/terminal/</guid><description>physical terminal和terminal emulator 很久以前，terminal是独立的机器，典型的代表是VT-100：
屏幕是输出，键盘是输入。
键盘上的敲击会被转化为电信号通过RS-232电缆发送到Computer对应的接口上，之后通过硬件和驱动被OS接收到；OS识别输入的具体意义，进行一些操作，然后回复，回复的内容通过驱动和硬件转化为电信号并发送回terminal，terminal接受到电信号之后，将其按照既定规则转化为屏幕上的字符。
所以，虽然感觉上是你敲击键盘直接在屏幕上打出文本，但其实键盘和屏幕之间并没有直接的联系；键盘的电信号只会发送给computer，而屏幕需要的电信号只会来自于computer。
当然现在没人用VT-100了，取而代之的是terminal emulator。我日常主要使用的terminal emulator是Mac上iterm2。
打开iterm2，你得到的是一个graphical application，除了边框，就是一块textual screen。
什么是textual screen？就是一块被划分了行和列的screen。换句话说，这是一块铺满格子的screen，每一个格子都可以被一个行标和一个列标唯一定位。
你在Mac上打开Finder等其他应用的时候，得到的也是一个graphical application，一块screen，但是这个screen是以pixel为单元的，每一个pixel都可以被唯一定位。
两者只是不同的computer display mode。
相对于后者，前者效率高，内存需求低，但能展示的界面也过于简单了，最多也就是sl(Steam Locomotive)的效果。 当下的主流，毫无疑问是后者。
terminal emulator和shell terminal emulator是一个executable，shell也是一个executable。
因为绝大多数terminal emulator打开之后在textual screen上呈现出来的是一个prompt，所以总给人一种terminal emulator和shell是不分你我的观感。
实际上，两者是完全独立的不同的process。
将两者联系起来的是pseduoterminal，pseduoterminal是属于kernel space的，换句话说，任何对pseduoterminal的操作都是通过system calls来完成的。
你可以将pseduoterminal看成是一个沟通不同process的桥梁，也就是一种IPC。
terminal emulator处于IPC的一端，shell处于IPC的另一端。
terminal emulator可以通过pseduoterminal将数据发送到shell，shell也可以通过pseduoterminal将数据发送到terminal emulator。
流程上，创建一个terminal emulator的process，创建一个executable的process，创建一个pseduoterminal，绑定terminal emulator process到pseudoterminal的一端，绑定shell process到pseduoterminal的另一端。
下图是TLPI介绍terminal related system calls时候使用的图片，对应的，可以认为terminal emulator就是一个driver program，shell就是一个terminal-oriented program；其中从driver program到terminal-oriented program的fork&amp;amp;exec过程不是必须的，但是是常见的操作。
打开iterm2，敲击键盘，对windowing system来说，这是key event；这些key events被terminal emulator这个window捕获，terminal emulator将之转化为数据通过pseduoterminal发送给shell，shell对发送过来的数据进行解释，比如执行ls命令之类的，然后将执行的结果转化为数据通过pseduoterminal发送会terminal emulator，而terminal emulator将根据数据调整textual screen上的视图，用户就在屏幕上看到结果。
这里值得一提的是shell发送给terminal emulator的数据。
这种数据叫做ANSI Escape Code Sequence，ANSI escape code你可以理解为操作textual screen的指令，包括但不限于：</description></item></channel></rss>